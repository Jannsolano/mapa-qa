<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>QA engineer</title>
    <link rel="stylesheet" href="estilos/style.css">
</head>
<body>
    <header id="cabecalho">
        <h1>Mapa do QA</h1>
    </header>
    <div class="col">
        <main class="conteudo">
            <h2 id="inicio">O que é o QA Engineer?</h2>
            <p>
                Seria o QA "completo", é aquele que entende da parte de processos, de testes, e desenvolvimento de automação.
            </p>
            <h2 id="resumo">1.Quality Assurance</h2>
            <h3>o que é QA(Quality Assurance)?</h3>
            <dl>
                <dt>Testes Manuais</dt>
                <dd>Garantir a qualidade do software</dd>
                <dt>Processos de Qualidade</dt>
                <dd>Criar um processo para garantir a qualidade do produto</dd>
                <dt>Programação</dt>
                <dd>Automatizar testes é parte fundamental para a qualidade</dd>
            </dl>
            <h3>Tecnologias usadas por QAs</h3>
            <dl>
                <dt>Automação Front-end</dt>
                <dd>Ferramentas como Cypress são usadas para automatizar testes de front-end</dd>
                <dt>Automação de Back-end</dt>
                <dd>Postman e Cypress para testes de APIs</dd>
                <dt>Automação Mobile</dt>
                <dd>testando aplicativos iOS e Android</dd>
            </dl>
            <h2 id="softesting">2.Software Testing</h2>
            <h3>O que é?</h3>
            <p>
                Software testing é o processo de avaliar e verificar se um software funciona como esperado, atende aos requisitos definidos e está livre de falhas (bugs) antes de ser lançado. O objetivo principal é garantir a qualidade, confiabilidade e usabilidade do produto final para o usuário.
            </p>
            <p>
                ele é dividido em duas etapas, o <strong>teste estático</strong> e o <strong>teste dinâmico</strong>
            </p>
            <div class="exemplo1">
                <h3 class="card1" id="softt">Software Testing</h3>
                <h4 class="arrow" id="e1arr1">&darr;</h4>
                <h4 class="arrow" id="e1arr2">&larr;&nbsp;&nbsp;&rarr;</h4>
                <h3 class="card1" id="statt">Teste estático</h3>
                <h3 class="card1" id="dintt">Teste dinâmico</h3>
            </div>
            <article>
                <h3>Teste estático</h3>
                <p>
                    tudo relacionado a qualidade, revisões do código, garantir padrões a ser seguido pela empresa no código, garantir o alinhamento do time, é a parte mais <strong>Profissional</strong>
                </p>
            </article>
            <article>
                <h3>Teste dinâmico</h3>
                <p>
                    entrar no aplicativo, procurar bugs, procurar problemas no app
                </p>
            </article>
            <article>
                <h3>Por sua vez temos mais uma divisão:</h3>
            </article>
            <div class="exemplo2">
                <h3 class="card1" id="softt">Software Testing</h3>
                <h4 class="arrow" id="e1arr1">&darr;</h4>
                <h4 class="arrow" id="e1arr2">&larr;&nbsp;&nbsp;&rarr;</h4>
                <h3 class="card1" id="statt">Validação</h3>
                <h3 class="card1" id="dintt">Verificação</h3>
            </div>
            <article>
                <h3>Validação</h3>
                <p>
                    Validar se o produto ficará satisfatório e útil para o usuário
                </p>
            </article>
            <article>
                <h3>verificação</h3>
                <p>
                    são os testes que fazemos para verificar se há problemas que complicam o uso do software ou bugs
                </p>
            </article>
            <h3>Objetivos do QA</h3>
            <ul>
                <li><em>Avaliação do produto</em> - saber se o produto funciona corretamente</li>
                <li><em>Cumprimento de requisitos</em> - validar se o software cumpre seu papel proposto</li>
                <li><em>Construir confiança</em> - realizar os testes e automações para dar confiança ao time pra dar deploy no produto</li>
                <li><em>Achar defeitos</em> - testar o sistema minuciosamente e procurar com esmero</li>
                <li><em>Prever bugs</em>- planejar antecipadamente quais problemas podem acontecer, e já fazer os testes para garantir que aconteçam</li>
                <li><em>Reports para Stakeholder</em> - quanto de cobertura de testes temos, dizer quais os testes realizados</li>
                <li><em>Reduzir Riscos</em> - sempre buscar garantir que o produto não terá bugs ou defeitos, para evitar riscos para a empresa</li>
            </ul>
            <div class="exemplo3">
                <h3 class="card1" id="e3carda">Avaliação do produto</h3>
                <h4 class="arrow" id="e3arr1">&rarr;</h4>
                <h3 class="card1" id="e3cardb">Cumprimento de requisitos</h3>
                <h4 class="arrow" id="e3arr2">&rarr;</h4>
                <h3 class="card1" id="e3cardc">Construir confiança</h3>
                <h4 class="arrow" id="e3arr3">&darr;</h4>
                <h3 class="card1" id="e3cardd">Achar defeitos</h3>
                <h4 class="arrow" id="e3arr4">&larr;</h4>
                <h3 class="card1" id="e3carde">Prever bugs</h3>
                <h4 class="arrow" id="e3arr5">&larr;</h4>
                <h3 class="card1" id="e3cardf">Reports para Stakeholder</h3>
                <h4 class="arrow" id="e3arr6">&darr;</h4>
                <h3 class="card1" id="e3cardg">Reduzir Riscos</h3>
            </div>
            <h3>Processos do Teste</h3>
            <h4>Planejamento de testes</h4>
            <ul>
                <li>Analisar e entender o produto</li>
                <li>Criar estratégias para um plano de ação</li>
                <li>Planejar</li>
                <li>Determinar as Ferramentas</li>
            </ul>
            <h4>Design</h4>
            <ul>
                <li>Casos de teste</li>
                <li>Cenarios de teste</li>
                <li>Desenvolver a Automação</li>
            </ul>
            <h4>Execução</h4>
            <ul>
                <li>Reporte de Teste</li>
                <li>Acompanhar defeitos</li>
                <li>Report</li>
            </ul>
            <h3>Principais tipos de teste</h3>
            <p>
                Lembrando que todos são importantes, lembrar de fazer todos independente da ordem que aqui estiverem listados
            </p>
            <ul>
                <li><em>Testes não funcionais</em> - são os testes que não são relacionados a funcionalidade do produto, ex: teste de extresse, de tempo de resposta, verificar capacidade do sistema</li>
                <li><em>Testes Funcionais</em> - categoriza como todos os testes de funcionalidade do produto</li>
                <li><em>Teste de caixa preta</em> - São os que fazemos no sistema sem acesso ao código</li>
                <li><em>Teste de caixa branca</em> - São so que testamos no código em si</li>
                <li><em>Teste Dinâmico</em> - são os que fazemos rodando o código</li>
                <li><em>Teste Estático</em> -toda a parte de criar os processos e padrões de teste</li>
                <li><em>Reteste</em> - verificamos e repetimos todos os testes das features para garantir que a correção dos bugs dos devs não acabaram quebrando o resto do sistema</li>
                <li><em>Testes unitários</em> - normalmente feito pelo dev, testa as funções, do código que acabou de ser criado</li>
                <li><em>Teste de Integração</em> - testar as features que se integram entre si, ex: feature de carrinho e a de compra</li>
                <li><em>Teste End-2-End</em> - são os testes pelo caminho que o usuário faz completamente até o fim do processo</li>
                <li><em>Teste Smoke</em> - é o que cuida das principais funcionalidades da aplicação, definir todas que devem ter a prioridade máxima de funcionamento</li>
                <li><em>Testes exploratórios</em> - É feito explorando como um usuário que nunca chegou a utilizar o sistema</li>
                <li><em>Teste de regressão</em> - rodar <strong>todos</strong> os testes já feitos para garantir que tudo foi passado e corrigido corretamente</li>
            </ul>
            <h3>Pirâmide de Testes</h3>
            <p>
                Ela indica quais testes são os mais rápidos e quais os mais demorados
            </p>
            <h4>End-to-end Tests</h4>
            <p>
                podem ser feitos manualmente ou por automação, ele vai ser bem mais demorado e custoso, pois vão testar toda a função feita como um usuário usaria o sistema
            </p>
            <h4>integrations Tests</h4>
            <p>
                acontecem tanto no código, quanto no sistema, nelas que fazemos os testes das features ficarem interagindo uma com a outra, podem ser feitos tanto manualmente como automatizados(como por cypress), é bastante feito por devs, mas são obrigação do QA também
            </p>
            <h4>Unit Tests</h4>
            <p>
                é o tipo de teste mais barato e rápido, normalmente os testes unitários são feitos pelos desenvolvedores, testa as funções de cada método, fica na base da pirâmide porque eles serão feitos milhares de vezes, porém acabarão ocupando pouquíssimo tempo, já que serão automatizados <em>a menos que eles não estejam otimizados</em>
            </p>
            <h3>Processos de scrum</h3>
            <h4>Entendendo cenários de testes</h4>
            <p>
                -entenda do produto -> lendo documentação, BRS, SRS, FRS, SUT
                -Usar o sistema
                -isolar os requisitos
                -listar cenários de teste
                -Revisão
            </p>
            <p>
                primeiramente entenda do produto, para isso Leia a documentação do produto
            </p>
            <h4>como criar cenarios de testes na ferramenta Trello</h4>
            <p>
            </p>
            <h4>Casos de Teste</h4>
            <ol>
                <li><em>Titulo</em></li>
                <li><em>Précondição</em></li>
                <li><em>Passo-a-passo dos testes</em></li>
                <li><em>Resultado Esperado</em></li>
                <li><em>Cenário de teste</em></li>
                <li><em>Ambiente de teste</em></li>
                <li><em>Status</em></li>
            </ol>
            <p>
                imagem de exemplo
            </p>
            <table>
                <tr>
                    <th>Título</th>
                    <th>Logando com email e senha válido</th>
                </tr>
                <tr>
                    <td>Passo-a-passo</td>
                    <td>inserir usuário válido/ inserir senha válida / Clicar em Login</td>
                </tr>
                <tr>
                    <td>Resultado esperado</td>
                    <td>usuário loga com sucesso / usuário é redirecionado para a página inicial</td>
                </tr>
                <tr>
                    <td>suite de teste</td>
                    <td>Login</td>
                </tr>
                <tr>
                    <td>Ambiente de teste</td>
                    <td>Google Chrome / Safari / Firefox</td>
                </tr>
                <tr>
                    <td>Resultado encontrado</td>
                    <td>O mesmo que o esperado</td>
                </tr>
                <tr>
                    <td>Status</td>
                    <td>Passou</td>
                </tr>
            </table>
            <p>
                O status é definido em 4 estados
            </p>
            <ul>
                <li>Pronto - quando ainda não foi testado</li>
                <li>Falhou</li>
                <li>Passou</li>
                <li>Bloqueado - quando não for possível fazer o teste</li>
            </ul>
            <h3>Tipos de Bug</h3>
            <ol>
                <li>Funcional</li>
                <li>Visual(UI)</li>
                <li>Conteúdo</li>
                <li>Performance</li>
                <li>Sugestão</li>
            </ol>
            <h3>Tópicos de um Bug Report</h3>
            <ol>
                <li>Passos para reprodução</li>
                <li>Resultado esperado</li>
                <li>Resultado Encontrado</li>
                <li>Ambiente de teste</li>
                <li>Prioridade</li>
                <li>Tipo</li>
                <li>Evidencia</li>
            </ol>
            <h3>Exemplos de bug report</h3>
            <p>planilha 1</p>
            <p>planilha 2</p>
            <p>planilha 3</p>
            <h3>técnica de Partição de Equivalência</h3>
            <p>é uma fórmula de particionar nosso teste para tentar reduzir o número de casos de teste necessários, agrupando entradas que se comportem da mesma forma</p>
            <p>
                exemplo, ao invés de testar cada valor de entrada possível, você divide os dados de entrada em <strong>classes de equivalência</strong> dentro de cada classe, se espera que o software se comporte da mesma forma entre os resultados, então você apenas seleciona UM representante de cada classe, pois os outros funcionarão da mesma forma
            </p>
            <h3>Processos de desenvolvimento</h3>
            <h4>SDLC(software Development Life Cycle)</h4>
            <h4>Waterfall</h4>
            <p>
                a ordem de passagem do produto vai em cascata na ordem
            </p>
            <ol>
                <li><em>Stakeholder</em>- gera a demanda e requisita a criação do aplicativo</li>
                <li><em>Produto(P.O./P.M.)</em> - cria as tasks e manda para a equipe de design</li>
                <li><em>Design</em> - cuidam do protótipo do aplicativo, e como ele ficaria no papel</li>
                <li><em>Implementation/Devs</em> - criam o aplicativo requisitado</li>
                <li><em>Testing/QA</em> - fazemos a revisão geral do produto</li>
                <li><em>Maintenance/Devs</em> - voltam para a equipe de desenvolvedores até estar devidamente corrigido e revisado</li>
                <li><em>Produto final</em></li>
            </ol>
            <h4>Scrum</h4>
            <p>
                O Scrum é um framework ágil para gerenciar e desenvolver produtos complexos, ideal para equipes que precisam se adaptar rapidamente às mudanças e entregar valor de forma incremental. Ele se baseia em ciclos curtos e repetitivos chamados Sprints.
            </p>
            <ol>
                <li><em>Product Backlog / Refinamento / Grooming:</em> No início, existe uma lista priorizada de tudo que o produto precisa ter, as funcionalidades e melhorias. Essa lista é chamada de Product Backlog e é mantida pelo Product Owner, que representa os interesses dos usuários e do negócio.</li>
                <li><em>Sprint Planning:</em> A equipe se reúne para planejar o próximo Sprint (geralmente de 1 a 4 semanas). Eles escolhem itens do Product Backlog que conseguirão entregar nesse período e os detalham, criando o Sprint Backlog.</li>
                <li><em>Sprint:</em> Durante o Sprint, a equipe de desenvolvimento trabalha para construir os itens selecionados. Eles são auto-organizados e se ajudam para entregar o que foi planejado.</li>
                <li><em>Daily Scrum (Reunião Diária):</em> Todos os dias, a equipe faz uma reunião rápida (até 15 minutos) para sincronizar o trabalho. Cada um responde a três perguntas: O que fiz ontem? O que farei hoje? Há algum impedimento?</li>
                <li><em>Incremento Pronto:</em> Ao final do Sprint, a equipe deve entregar um Incremento de Produto que seja "pronto" (potencialmente utilizável, testado e funcionando).</li>
                <li><em>Sprint Review:</em> A equipe apresenta o incremento pronto para os stakeholders (interessados), que dão feedback e sugerem ajustes para futuras Sprints.</li>
                <li><em>Sprint Retrospective:</em> Sprint Retrospective: A equipe se reúne para refletir sobre o Sprint que acabou. Eles identificam o que funcionou bem, o que pode ser melhorado e criam um plano para implementar essas melhorias nos próximos Sprints.</li>
            </ol>
            <h4>Testes em cada momento do scrum</h4>
            <p>
                na fase de refinamento(Grooming) devemos <strong>Criar cenários de teste</strong>
            </p>
            <p>
                na fase de planning devemos <strong>Ter casos de teste prontos ou perto de finalizar
                </strong>
            </p>
            <p>
                e na fase de retrospectiva ou Review teremos os Bug reports e Tests Reports
            </p>
            <p>
                após o projeto estar na fileira <em>Done</em> e soltar a release, faremos <strong>Testes de Regressão(Manual e automatizados)</strong>
            </p>
            <p>
                e caso ele já tenha saído pra Produção, podemos realizar mais uma vez os testes de Regressão, ou se não for possível, os <strong>Smoke tests(manual e automatizado)</strong>
            </p>
            <p>
                <strong>Produção</strong>
                é onde o usuário já tem acesso
            </p>
            <h2 id="JavaScptAutomation">3.JavaScript para automação</h2>
            <h3>Variáveis</h3>
            <p>
                uma variável é um espaço de memória que irá guardar um valor
            </p>
            <ul>
                <li>Number - atrelado a números</li>
                <li>String - geralmente atrelado a palavras, as quais precisam estar com aspas para serem reconhecidas</li>
                <li>Boolean - atrelado a binariedade, retorna ou true ou false</li>
                <li>Array - referenciado com [] precisa ser chamado pelo nome da variável, e o valor dentro das chaves com a posição desejada para retornar o item da posição</li>
                <li>Object - referenciado por {}, para ser chamado na função, basta chamar com o nome da variável, seguida de um ponto e a classe interior</li>
                <li>Date - utilizado para buscar datas</li>
            </ul>
            <h4>diferença de let, const e var</h4>
            <p>
                quando vc cria uma variável com <em>let</em>
                ela poderá ser alterado quando pedido novamente
            </p>
            <p>
                quando vc cria uma variável com <em>const</em>
                ela <strong>não</strong> poderá ser alterada enquanto o seu programa estiver rodando
            </p>
            <p>
                o var é uma forma <STRONG>DEPRECIADA</STRONG> de se declarar variáveis, desde 2015 não é mais utilizado, ele tinha a mesma função do let, mas não é mais utilizado
            </p>
            <h4>Como alterar dados do object</h4>
            <p>
                suponhamos que temos a seguinte linha
            </p>
            <pre><code>
                pessoa {Nome: 'Many', Idade: 28, Casado: true, Pais: 'Canadá'}
            </code></pre>
            <p>
                se utilizarmos o comando <q>pessoa = 'alessandro'</q> para mudar o nome, perderemos todos os outros dados salvos no objeto e ele só retornará 'alessandro'
            </p>
            <p>
                então teremos que fazer da seguinte forma
            </p>
            <pre><code>
                pessoa.Nome = "Alessandro"
            </code></pre>
            <p>
                dessa forma apenas a classe "Nome" terá mudado seus dados, e ao ser chamado o objeto retornará todos os valores com apenas o nome alterado
            </p>
            <pre><code>
                pessoa {Nome: 'Alessandro', Idade: 28, Casado: true, Pais: 'Canadá'}
            </code></pre>
            <h4>como alterar os dados do Array</h4>
            <p>
                seguindo a mesma lógica, mas ao invés de buscarmos a posição do dado pela classe, pegaremos pela posição dele na ordem que inicia pelo número zero
            </p>
            <pre><code>
                array [10, 12, 'text', true, false, 'Test']
            </code></pre>
            <p>
                iremos alterar o número 12, que está na posição 1(logo após o 0)
            </p>
            <pre><code>
                array[1] = 100
            </code></pre>
            <p>assim esse será o resultado final</p>
            <pre><code>
                array [10, 100, 'text', true, false, 'Test']
            </code></pre>
            <h4>Concatenação de dados</h4>
            <p>
                concatenar, ou "juntar" serve normalmente para unir strings, como letras não se somam, elas irão se ordenar da forma descrita
            </p>
            <pre><code>
                let test1 = "super"
                let test2 = "poder"
            </code></pre>
            <p>
                ao tentar unir com um <q>let juntos = test1 + test2</q>
            </p>
            <p>
                o console retornará a palavra "superpoder" ao chamar pela variável juntos
            </p>
            <pre><code>
                let juntos = test1 + " " + test2
            </code></pre>
            <p>
                agora sim, dessa forma o console retornará as palavras "super poder" já que o caractere em branco foi incluído na equação
            </p>
            <p>
                existem outras formas de fazer o console retornar como
            </p>
            <pre><code>
                juntos = `${test1} ${test2}`
            </code></pre>
            <p>
                assim eu estou invocando as variáveis com duas crases
            </p>
            <h4>imprimindo informações no sistema</h4>
            <p>
                para imprimir, utilizamos o <strong>console.log()</strong>
            </p>
            <h4>funções simples</h4>
            <p>
                para fazer uma função, temos que escrever <em>function</em>, dar um nome pra função, e fechar parênteses, em seguida abrir colchetes e escrever a função desejada dentro, exemplo:
            </p>
            <pre><code>
                function soma(){
                    return 10+12
                }
            </code></pre>
            <p>
                nesse caso o <em>return</em> foi utilizado para retornar a soma, sem ele apenas haveriam dois valores somados sem nenhuma utilidade
            </p>
            <p>
                e para mostrar o resultado basta adicionar
            </p>
            <pre><code>
                console.log(soma())
            </code></pre>
            <p>
                que pode ser inserido até dentro da função, mas pra ela rodar vai ter que ser chamada em algum lugar do sistema
            </p>
            <pre><code>
                function soma() {
                    console.log(10+12)
                }
                soma()
            </code></pre>
            <p>
               no exemplo acima o console irá retornar pela soma ter sido chamada diretamente, mas é melhor manter o return, ou continuar com o pretendido inicialmente
            </p>
            <pre><code>
                function soma() {
                    return 10+12
                }
                console.log(soma())
            </code></pre>
            <p>
                <q>E para que servem os parênteses na função soma?</q> eles servem para inserir parâmetros qualquer que seja necessário dependendo da nossa necessidade
            </p>
            <pre><code>
                function soma(x, y) {
                    return x + y
                }
                console.log(soma())
            </code></pre>
            <p>
                este exemplo acima retornará como <q>NaN(Not a Number)</q> pois os números não foram inseridos, x e y nesse caso são apenas letras, mas se fizermos:
            </p>
            <pre><code>
                function soma(x, y) {
                    return x + y
                }
                console.log(soma(50, 20))
            </code></pre>
            <p>
                o console vai nos retornar qualquer soma que inserirmos no lugar daquelas letras
            </p>
            <pre><code>
                function soma(x, y) {
                    return x + y
                }
                function sub(x, y) {
                    return x - y
                }
                console.log(sub(50,20))
                console.log(soma(50, 20))
                resultado:
                30
                70
            </code></pre>
            <p>
                as funções só rodam quando são chamadas, e se elas não forem chamadas no console.log continuam rodando, só não conseguimos visualizar
            </p>
            <h4>Mais exemplos</h4>
            <pre><code>
                function textCreator(name, age, currentYear) {
                let birthYear = currentYear - age
                return `Seu nome é ${name}, idade é ${age}, e o ano atual é ${currentYear}. Você nasceu em ${birthYear}`
            }
                console.log(textCreator("many", 28, 2023))
            </code></pre>
            <p>
                o código acima coleta os dados inseridos no chamado da função e retorna o ano de nascimento, também é possível fazer o mesmo com concatenação
            </p>
            <pre><code>
                function textCreator(name, age, currentYear) {
                let birthYear = currentYear - age
                return "Seu nome é " + name + ", idade é " + age + ", e o ano atual é " + currentYear + ". Você nasceu em " + birthYear
                }
                console.log(textCreator("many", 28, 2023))
            </code></pre>
            <p>
                mas da outra forma é mais legível no código, melhor que ficar concatenando e somando várias strings
            </p>
            <h4>Condições</h4>
            <p>
                As condições são blocos de código que permitem que seu programa tome decisões, <b>verificam</b> se algo é verdadeiro ou falso, para então executar uma ação
            </p>
            <p>
                Para isso utilizaremos o If
            </p>
            <pre><code>
                let idade = 18;

                if (idade >= 18) {
                console.log("Você pode dirigir!");
                } else {
                console.log("Você ainda não pode dirigir.");
                }
            </code></pre>
            <p>
                Isso deixa o código dinâmico, pois a ação vai ser executada dependendo de um valor ou situação específica
            </p>
            <h4>Arrays</h4>
            <p>
                um array é uma lista ordenada de valores. É como uma caixa com compartimentos numerados, onde você pode guardar vários itens, como números, textos ou até mesmo outros arrays
            </p>
            <pre><code>
                let listaDeFrutas = ["Maçã", "Banana", "Laranja"];

                console.log(listaDeFrutas[0]); // Saída: Maçã
                console.log(listaDeFrutas[2]); // Saída: Laranja
                console.log(listaDeFrutas.length); // Saída: 3
            </code></pre>
            <ul>
                <li>let listaDeFrutas = ["Maçã", "Banana", "Laranja"]; cria um array com três itens.</li>
                <li>Você pode acessar cada item usando sua posição (chamada de índice), que sempre começa em 0. Por isso, listaDeFrutas[0] é "Maçã".</li>
                <li>.length é uma propriedade que diz quantos itens o array possui.</li>
            </ul>
            <h4>Loops</h4>
            <p>
                Os loops são estruturas que permitem executar um bloco de código repetidamente.
            </p>
            <pre><code>
                let array = [10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25] 
                let x = 0

                while (x &lt; array.length) {
                    console.log(array[x])
                    x = x + 1
                }
            </code></pre>
            <p>
                No código acima, estamos dizendo que enquanto o valor de x for menor que o tamanho do array, ele vai mostrar no console a posição seguinte do array até ele terminar
            </p>
            <p>
                também funciona com strings, não só com números
            </p>
            <p>
                também é possível fazer com o <b>For</b>
            </p>
            <pre><code>
                let array = [10, "test", "palavra", false, 42]
                let x = 0

                for (let index = 0; index &lt; 10; index++) {
                    console.log("número de index é: " + index)
                    console.log("Valor da posição é: " + array[index])
                }
            </code></pre>
            <p>
                Lembre-se de sempre fazer alguns exercícios de programação para não perder o costume.
            </p>
            <h2 id="HtmlAu">4. Entendendo HTML para automação</h2>
            <h3>Estrutura básica de um elemento HTML</h3>
            <p>
                Um elemento HTML costuma ter
            </p>
            <pre><code>
                &lt;tag atributo="valor"&gt;conteúdo&lt;/tag&gt;
                exemplo
                &lt;button id="login-btn" class="btn-prime"&gt;entrar&lt;/button&gt;
            </code></pre>
            <p>
                aqui temos:
            </p>
            <ul>
                <li>Tag: button</li>
                <li>Atributos: id, class</li>
                <li>Conteúdo: Entrar</li>
            </ul>
            <h3>🔹 Principais atributos usados em automação</h3>
            <ul>
                <li>id → único na página (preferência nº1)</li>
                <li>name → muitas vezes usado em formulários</li>
                <li>class → pode repetir em vários elementos (cuidado)</li>
                <li>data- (atributos customizados)* → exemplo: data-cy="login-button" (ótimo para testes, porque são feitos para isso)</li>
                <li>type, href, alt, title, value, placeholder → usados em inputs, links, imagens etc.</li>
            </ul>
            <h3>🔹 Como inspecionar elementos</h3>
            <ol>
                <li>Abrir o DevTools → Clique com botão direito → "Inspecionar".</li>
                <li>Na aba Elements, passe o mouse no código → o site destaca o elemento.</li>
                <li>Clique com direito no código → Copy → Copy selector / Copy XPath (gera um seletor, mas muitas vezes precisa ser ajustado).</li>
                <li>Ver atributos únicos e escolher o melhor.</li>
            </ol>
            <h4>
                para automação, o QA precisa ler a estrutura do HTML, identificar atributos estáveis e escolher seletores únicos.
            </h4>
            <h3>🔹 Seletores únicos (CSS e XPath)</h3>
            <h4>CSS Selectors (mais usados em Cypress, Playwright, Selenium moderno)</h4>
            <ul>
                <li>Por id: #login-btn</li>
                <li>Por class: .btn.primary</li>
                <li>Por atributo: [data-cy="login-button"]</li>
                <li>Por tag + atributo: input[name="email"]</li>
                <li>Por hierarquia: form > input[type="password"]</li>
            </ul>
            <h4>XPath (mais comum em Selenium)</h4>
            <ul>
                <li>Absoluto (ruim): /html/body/div[2]/form/input[1]</li>
                <li>Relativo (bom): //input[@name='email']</li>
                <li>Por texto: //button[text()='Entrar']</li>
                <li>Combinando condições: //div[@class='card' and @id='login-card']</li>
            </ul>
            <h3>🔹 Boas práticas para QA</h3>
            <ol>
                <li>Prefira id ou data-* → são estáveis e únicos.</li>
                <li>Evite selecionar por texto ou posição (ex: nth-child, div[3]) → quebra fácil.</li>
                <li>Combine atributos para garantir unicidade → ex: input[type="email"][name="userEmail"].</li>
                <li>Se possível, peça para o time de dev adicionar atributos data-testid, data-cy, data-qa.</li>
            </ol>
            <p>
                Isso garante que os testes não quebrem facilmente quando o site mudar.
            </p>
            <h2 id="AuCypress">5. Automação de Testes com Cypress</h2>
            <p>
                pré requisitos: primeiro instale o Node.js, Git, Visual Code, Github desktop(opcional)
            </p>
            <h3>Iniciando o projeto cypress</h3>
            <ol>
                <li>Escolha um diretório e crie sua pasta do projeto</li>
                <li>Uma vez selecionado, abra o terminal e digite:</li>
                <ul>
                    <li>npm init</li>
                    <li>npm install cypress --save-dev</li>
                </ul>
                <li>Abra a pasta no Visual Code</li>
                <li>Digite no terminal: npx cypress open</li>
                <li>Ao iniciar o Cypress, escolha o navegador preferido</li>
                <li>Crie os specs de teste</li>
                <li>Coloque o domínio do site a testar no cy.visit</li>
            </ol>
            <h3>Comandos mais utilizados para automatizar</h3>
            <h4>🔹 1. Navegação</h4>
            <li>cy.visit('url') → abre a página</li>
            <pre><code>cy.visit('http://localhost:3000/login')</code></pre>
            <li>cy.url() → pega a URL atual</li>
            <pre><code>cy.url().should('include', '/login')</code></pre>
            <h4>2. Encontrar elementos</h4>
            <li>cy.get('selector') → pega elemento pelo seletor CSS</li>
            <pre><code>
            cy.get('#login-btn')         // por ID
            cy.get('.btn.primary')       // por classe
            cy.get('[data-cy="email"]')  // por atributo customizado
            </code></pre>
            <li>cy.contains('texto') → busca pelo texto visível</li>
            <pre><code>
            cy.contains('Entrar').click()
            </code></pre>
            <h4>🔹 3. Interagir com elementos</h4>
            <li>Click:</li>
            <pre><code>
            cy.get('#login-btn').click()
            </code></pre>
            <li>Digitar texto:</li>
            <pre><code>
            cy.get('[data-cy="email"]').type('teste@email.com')

            cy.get('[data-cy="password"]').type('123456')
            </code></pre>
            <li>Limpar campo:</li>
            <pre><code>
            cy.get('[data-cy="email"]').clear()
            </code></pre>
            <li>Selecionar em dropdown:</li>
            <pre><code>
            cy.get('select').select('Opção 1')
            </code></pre>
            <li>Checkbox / Radio:</li>
            <pre><code>
            cy.get('[type="checkbox"]').check()
            cy.get('[type="checkbox"]').uncheck()
            cy.get('[type="radio"]').check('valor')
            </code></pre>
            <h4>🔹 4. Assertions (validações)</h4>
            <li>Should (expectativas):</li>
            <pre><code>
            cy.get('#login-btn').should('be.visible')
            cy.get('#login-btn').should('contain', 'Entrar')
            cy.get('[data-cy="email"]').should('have.value', 'teste@email.com')
            </code></pre>
            <li>Chaining (encadeamento):</li>
            <pre><code>cy.get('.alert').should('be.visible').and('contain', 'Erro')</code></pre>
            <h4>🔹 5. Esperas e sincronização</h4>
            <p>Cypress já espera automaticamente, mas às vezes precisa de algo extra</p>
            <li>Esperar elemento aparecer:</li>
            <pre><code>cy.get('.loading-spinner', { timeout: 10000 }).should('not.exist')</code></pre>
            <li>Esperar tempo fixo (não recomendado, só emergencial):</li>
            <pre><code>cy.wait(2000)</code></pre>
            <h4>🔹 6. Trabalhando com listas / elementos múltiplos</h4>
            <li>Primeiro / último:</li>
            <pre><code>
            cy.get('ul li').first().click()
            cy.get('ul li').last().click()
            </code></pre>
            <li>Por índice:</li>
            <pre><code>cy.get('ul li').eq(2).click() // terceiro item (índice começa em 0)</code></pre>
            <li>Iterar em lista:</li>
            <pre><code>
            cy.get('ul li').each(($el, index) => {
                cy.log(`Item ${index}: ${$el.text()}`)
            })</code></pre>
            <h4>🔹 7. Requisições (API)</h4>
            <li>cy.request() → útil para setups de teste ou validar API junto com front.</li>
            <pre><code>cy.request('GET', '/api/users').its('status').should('eq', 200)</code></pre>
            <h4>🔹 8. Uploads / Downloads</h4>
            <li>Com plugin cypress-file-upload:</li>
            <pre><code>cy.get('input[type="file"]').attachFile('arquivo.pdf')</code></pre>
            <h4>🔹 9. Armazenando dados</h4>
            <li>Alias de elementos:</li>
            <pre><code>
            cy.get('#login-btn').as('botaoLogin')
            cy.get('@botaoLogin').click()
            </code></pre>
            <li>Salvar valores:</li>
            <pre><code>
            cy.get('#user').invoke('text').then((user) => {
                cy.log(user) // usar valor capturado
            })
            </code></pre>
            <h4>🔹 10. Screenshots e gravações</h4>
            <li>Tirar screenshot:</li>
            <pre><code>cy.screenshot('nome-do-print')</code></pre>
            <li>Gravação automática de vídeo:</li>
            <pre><code>(Cypress já faz por padrão no <b>cypress run</b>).</code></pre>
            <h2 id="PostmanApi">6. Testes de API</h2>
            <p>

            </p>
            <h2 id="database">7. Banco de dados</h2>
            <ul>
                <li>Banco de Dados (BD): Local organizado para guardar informações.</li>
                <li>SGBD (Sistema Gerenciador de Banco de Dados): Software que gerencia o BD (ex: PostgreSQL, MySQL, Oracle, SQL Server).</li>
                <li>SQL (Structured Query Language): Linguagem padrão para manipular BD.</li>
                <li>Tabelas: Estruturas com linhas (registros) e colunas (campos).</li>
                <li>CRUD: Operações principais:</li>
                <ul>
                    <li>Create → inserir</li>
                    <li>Read → consultar</li>
                    <li>Update → atualizar</li>
                    <li>Delete → excluir</li>
                </ul>
            </ul>
            <h3>🐘 PostgreSQL – Exemplos básicos de SQL</h3>
            <h4>🔹 1. Criar uma tabela</h4>
            <pre><code>
            CREATE TABLE usuarios (
                id SERIAL PRIMARY KEY,
                nome VARCHAR(100),
                email VARCHAR(100) UNIQUE,
                idade INT
                );
            </code></pre>
            <h4>🔹 2. Inserir dados (Create)</h4>
            <pre><code>
            INSERT INTO usuarios (nome, email, idade)
            VALUES ('João Silva', 'joao@email.com', 30);
            </code></pre>
            <p>
                Inserir múltiplos de uma vez:
            </p>
            <pre><code>
            INSERT INTO usuarios (nome, email, idade)
            VALUES 
                ('Maria', 'maria@email.com', 25),
                ('Carlos', 'carlos@email.com', 40);
            </code></pre>
            <h4>🔹 3. Consultar dados (Read)</h4>
            <li>Todos os registros:</li>
            <pre><code> SELECT * FROM usuarios; </code></pre>
            <li>Apenas algumas colunas:</li>
            <pre><code> SELECT nome, email FROM usuarios; </code></pre>
            <li>Com condição:</li>
            <pre><code> SELECT * FROM usuarios WHERE idade > 30; </code></pre>
            <li>Ordenar:</li>
            <pre><code> SELECT * FROM usuarios ORDER BY idade DESC; </code></pre>
            <h4>🔹 4. Alterar dados (Update)</h4>
            <pre><code>
            UPDATE usuarios
            SET idade = 31
            WHERE id = 1;
            </code></pre>
            <h4>🔹 5. Excluir dados (Delete)</h4>
            <pre><code> DELETE FROM usuarios WHERE id = 2; </code></pre>
            <p>Apagar todos (cuidado ⚠️):</p>
            <pre><code> DELETE FROM usuarios; </code></pre>
            <h4>🔹 6. Popular múltiplas tabelas</h4>
            <p>
                Exemplo: usuarios e pedidos.
            </p>
            <pre><code>
            CREATE TABLE pedidos (
                id SERIAL PRIMARY KEY,
                produto VARCHAR(100),
                valor DECIMAL(10,2),
                usuario_id INT REFERENCES usuarios(id)
            );

            INSERT INTO pedidos (produto, valor, usuario_id)
            VALUES
                ('Notebook', 3500.00, 1),
                ('Celular', 2000.00, 1),
                ('Fone de Ouvido', 300.00, 2);
            </code></pre>
            <h4>🔹 7. INNER JOIN (consultar dados relacionados)</h4>
            <p>
                INNER JOIN serve para juntar dados de duas (ou mais) tabelas que têm algo em comum.
            </p>
            <ul>
                <li>Ele retorna apenas os registros que existem em ambas as tabelas (a interseção).</li>
                <li>Normalmente a ligação é feita através de chave primária (PK) em uma tabela e chave estrangeira (FK) em outra.</li>
            </ul>
            <p>Exemplo prático:</p>
            <li>Tabela <b>usuários</b></li>
            <table>
                <tr>
                    <th>id</th>
                    <th>nome</th>
                </tr>
                <tr>
                    <td>1</td>
                    <td>João</td>
                </tr>
                <tr>
                    <td>2</td>
                    <td>Maria</td>
                </tr>
            </table>
            <li>Tabela <b>pedidos</b></li>
            <table>
                <tr>
                    <th>id</th>
                    <th>produto</th>
                    <th>usuario_id</th>
                </tr>
                <tr>
                    <td>1</td>
                    <td>Notebook</td>
                    <td>1</td>
                </tr>
                <tr>
                    <td>2</td>
                    <td>Celular</td>
                    <td>1</td>
                </tr>
                <tr>
                    <td>3</td>
                    <td>Fone</td>
                    <td>2</td>
                </tr>
            </table>
            <p>Consulta com INNER JOIN:</p>
            <pre><code>
            SELECT u.nome, p.produto
            FROM usuarios u
            INNER JOIN pedidos p ON u.id = p.usuario_id;
            </code></pre>
            <p>➡️ Resultado:</p>
            <table>
                <tr>
                    <th>nome</th>
                    <th>produto</th>
                </tr>
                <tr>
                    <td>João</td>
                    <td>Notebook</td>
                </tr>
                <tr>
                    <td>João</td>
                    <td>Celular</td>
                </tr>
                <tr>
                    <td>Maria</td>
                    <td>Fone</td>
                </tr>
            </table>
            <h2 id="MobileAu">8. Automação mobile com Appium</h2>
            <p>
                Primeiro precisamos setar o ambiente de automação mobile
            </p>
            <h3>Ferramentas utilizadas:</h3>
            <li><a href="https://nodejs.org/pt">Node.js</a></li>
            <li><a href="https://openjdk.org">Open JDK</a></li>
            <li><a href="https://webdriver.io">Webdriver.io</a></li>
            <li><a href="https://developer.android.com/studio?hl=pt-br">Android Studio</a></li>
            <p>Após a instalação do Node e do OpenJDK, vamos setar as variáveis de ambiente no sistema operacional</p>
            <ol>
                <li>Pesquise no windows <b>Variáveis de ambiente</b></li>
                <li>ao abrir a janela procure a opção "Enviroment Variables...."</li>
                <li>Então criar nova variável em "System variables"</li>
                <li>defina um nome como JAVA_HOME</li>
                <li>coloque o valor da variavel de ambiente, ex: E:\Java\jdk-22</li>
            </ol>
            <h3>Setup do Android Studio</h3>
            <ol>
                <li>Inicie o instalador</li>
                <li>Abra o android studio, não precisa importar nada</li>
                <li>Crie um new project, no activity</li>
                <li>defina o nome do dispositivo, versão do android, e API</li>
                <li>vá para Device manager caso necessário baixar outras versões</li>
            </ol>
            <h3> Setando a variável do Android Home </h3>
            <ol>
                <li>Vá para a mesma janela do System variables</li>
                <li>Crie uma nova chamada ANDROID_HOME</li>
                <li>Cole no variable value o diretório da pasta AppData\Local\Android\Sdk</li>
                <li>Salve e feche tudo </li>
            </ol>
            <h3> Setup do Appium </h3>
            <ol>
                <li>vá no repositório do github do Appium inspector</li>
                <li>siga para <a href="https://github.com/appium/appium-inspector/releases">Releases</a></li>
                <li>escolha a versão mais recente</li>
                <li>baixe, run anyway</li>
                <li>faça a instalação do setup</li>
                <li>abra o appium-inspector</li>
                <li>vá no terminal do bash e digite <b>npm install -g appium</b> caso não dê certo, clique <a href="https://appium.io/docs/en/latest/quickstart/install">Aqui</a></li>
                <li>uma vez instalado, basta digitar <b>appium</b> no bash para rodar</li>
                <li>para checar se está tudo okay, instale o <b>npm install appium-doctor -g</b></li>
                <li>dessa forma, rodando no bash o comando <b>appium-doctor</b> ele irá checar se sua instalação do appium está okay, para acessar o repositório do appium-doctor, clique <a href="https://github.com/appium/appium-doctor">aqui</a></li>
                <li>E por fim temos que instalar o <a href="https://appium.io/docs/en/latest/quickstart/uiauto2-driver">UiAutomator2</a> utilizando essa linha no Bash: <b>appium driver install uiautomator2</b></li>
                <li>digitar o comando <b>appium driver list</b> irá listar todos os drivers(caso precise de um driver para IOS baixe o xcuitest)</li>
            </ol>
            <h3> Setup do WebdriverIO </h3>
            <ol>
                <li>acesse o site do <a href="https://webdriver.io"></a> caso precise checar a documentação</li>
                <li>crie a pasta do projeto</li>
                <li>abra a pasta com o visual code</li>
                <li>abra o terminal do git bash no visual code para facilitar a visualização</li>
                <li>Agora sim podemos rodar o comando <b>npm init wdio@latest .</b></li>
                <li>selecione "yes" para continuar e confirme a pasta</li>
                <li>escolha a opção E2E Testing - of Web or Mobile Applications</li>
                <li>então escolha Local machine</li>
                <li>environment escolha Mobile</li>
                <li>e confirme Android</li>
                <li>framework pode ser Mocha ou Cucumber, nesse caso vamos de <a href="https://mochajs.org">Mocha</a></li>
                <li>Typescript: "no"</li>
                <li>webdriver autogenerate test files: "yes"</li>
                <li>location: manter</li>
                <li>page objects: yes</li>
                <li>location: manter</li>
                <li>Which reporter: spec</li>
                <li>add plugin: wait-for</li>
                <li>visual testing? "No"</li>
                <li>add a service: appium</li>
                <li>npm install: yes</li>
                <li>continue appium setup: "yes"</li>
                <li>need help setting up Android Environment?</li>
                <li>Android Emulator</li>
                <li>browser: none</li>
                <li>download missing binaries and complete setup: yes</li>
                <li>exit</li>
            </ol>
            <h3>Baixe uma aplicação .apk</h3>
            <li>após fazer o download do aplicativo, crie uma pasta app na raiz do projeto</li>
            <li>no Android Studio configure um novo dispositivo com o mesmo tipo de celular, mas com uma versão e API diferentes do Android</li>
            <h3>Configurando as capabilities</h3>
            <li>No appium Inspector vc vai ter que ir no Capability builder e colocar as informações da automação em ordem</li>
            <ol>
                <li>platformName "Android"</li>
                <li>appium:platformVersion "versão do Android"</li>
                <li>appium:deviceName "nome do celular emulado, e a versão da API"</li>
                <li>appium:app "local do apk"</li>
                <li>appium:automationName "nome da automação, pode ser algo como uiautomator2"</li>
            </ol>
            <li>com tudo isso configurado, você pode iniciar uma sessão após iniciar o appium no git bash com o comando <b>appium -p 4724</b></li>
            <li>essa porta é utilizada no appium inspector, pq o webdriver utiliza a padrão 4723 para rodar o aplicativo</li>
            <li>para utilizar os dois celulares emulados ao mesmo tempo, copiamos as capabilities do appium inspector, e colamos na área capabilities do arquivo <b>Wdio.config.js</b></li>
            <li>agora ao abrir o Appium inspector ele deve interagir com os 2 celulares do Android studio</li>
            <h2 id="syllabus">ISQTB Foundation Level</h2>
            <h3>Capítulo 1 – Fundamentos do Teste</h3>
            <p>
                👉 Tema: O que é teste, por que testar e princípios básicos.
            </p>
            <ul>
                <li><b>O que é teste:</b> Avaliar um software para encontrar defeitos, reduzir riscos e aumentar confiança na qualidade.</li>
                <li><b>Defeito vs Falha vs Erro:</b></li>
                <ul>
                    <li>Erro (Mistake): falha humana (ex: programador esqueceu uma condição).</li>
                    <li>Defeito (Bug/Fault): problema no código.</li>
                    <li>Falha (Failure): quando o defeito aparece na execução.</li>
                </ul>
                <li>Objetivos do teste: encontrar falhas, prevenir defeitos, dar confiança no sistema.</li>
                <li>Princípios do teste (7):</li>
                <ol>
                    <li>Testar mostra presença de defeitos, não a ausência.</li>
                    <li>Teste exaustivo é impossível.</li>
                    <li>Testar cedo é mais barato.</li>
                    <li>Defeitos se agrupam (mais comuns em áreas críticas).</li>
                    <li>Paradoxo do pesticida: repetir os mesmos testes deixa de encontrar novos bugs.</li>
                    <li>Teste depende do contexto (ex: teste para app bancário ≠ teste para jogo).</li>
                    <li>Ilusão da ausência de erros: sistema sem bugs não significa útil se não atender necessidades.</li>
                </ol>
                <li>Psicologia do teste: Devs e testers têm visões diferentes → importante comunicação clara.</li>
            </ul>
            <h3>Capítulo 2 – Teste Durante o Ciclo de Vida do Software</h3>
            <p>
                👉 Tema: Onde os testes entram no desenvolvimento.
            </p>
            <ul>
                <li>Modelos de ciclo de vida:</li>
                <ul>
                    <li>Cascata: fases sequenciais.</li>
                    <li>Incremental/Iterativo: feito em partes.</li>
                    <li>Ágil: entregas rápidas e testes contínuos.</li>
                </ul>
                <li>Níveis de teste (de menor para maior):</li>
                <ol>
                    <li>Unitário (Componente): cada pedacinho isolado.</li>
                    <li>Integração: verificar como módulos trabalham juntos.</li>
                    <li>Sistema: testar o software completo.</li>
                    <li>Aceitação: cliente valida se atende necessidades.</li>
                </ol>
                <li>Tipos de teste:</li>
                <ul>
                    <li>Funcional: o que o sistema faz (requisitos).</li>
                    <li>Não-funcional: desempenho, usabilidade, segurança etc.</li>
                    <li>Estrutural (caixa-branca): olhar dentro do código.</li>
                    <li>Mudança: regressão e confirmação (retestar após alterações).</li>
                </ul>
                <li>Atividades de teste: <br>
                    Planejar → Monitorar & Controlar → Analisar → Projetar → Implementar → Executar → Encerrar.
                </li>
                <li>Artefatos de teste: plano, casos de teste, suites, relatórios.</li>
            </ul>
            <h3>Capítulo 3 – Teste Estático</h3>
            <p>
                👉 Tema: Encontrar problemas sem rodar o sistema.
            </p>
            <ul>
                <li>Teste dinâmico vs estático:</li>
                <ul>
                    <li>Dinâmico: executar o software.</li>
                    <li>Estático: revisar documentos, código e requisitos sem execução.</li>
                </ul>
                <li>Benefícios: barato, pega erros cedo (ex: ambiguidade nos requisitos).</li>
                <li>Revisões (tipos):</li>
                <ol>
                    <li>Informal (ex: par lê seu código).</li>
                    <li>Revisão por pares.</li>
                    <li>Revisão técnica.</li>
                    <li>Inspeção (mais formal, com papéis definidos).</li>
                </ol>
                <li>Análise estática de código: ferramentas que apontam más práticas, código morto, vulnerabilidades.</li>
            </ul>
            <h3>Capítulo 4 – Técnicas de Teste</h3>
            <p>
                👉 Tema: Como projetar casos de teste.
            </p>
            <ul>
                <li>Caixa-preta (baseada em especificação):</li>
                <ul>
                    <li>Particionamento de equivalência: dividir entradas em grupos válidos/ inválidos.</li>
                    <li>Valores-limite: testar bordas (ex: 0, 1, máximo).</li>
                    <li>Tabela de decisão: combinações de regras.</li>
                    <li>Transição de estados: testar mudanças de estado (ex: login → logado → logout).
</li>
                    <li>Caso de uso: baseado no que o usuário faz.</li>
                </ul>
                <li>Caixa-branca (baseada em estrutura):</li>
                <ul>
                    <li>Testar caminhos do código: instruções, decisões, loops.</li>
                    <li>Métricas: cobertura de instruções, de decisão, etc.</li>
                </ul>
                <li>Baseada em experiência:</li>
                <ul>
                    <li>Teste exploratório, checklist, ataques de erro → usar conhecimento e intuição do tester.</li>
                </ul>
            </ul>
        </main>
        <aside class="menuLateral">
            <button onclick="location.href='#inicio'">
                <a class="nav" href="#inicio">O que é o QA Engineer?</a>
            </button>
            <button onclick="location.href='#resumo'">
                <a class="nav" href="#resumo">Quality Assurance</a>
            </button>
            <button onclick="location.href='#softesting'">
                <a class="nav" href="#softesting">Software Testing</a>
            </button>
            <button onclick="location.href='#JavaScptAutomation'">
                <a class="nav" href="#JavaScptAutomation">JavaScript para automação</a>
            </button>
            <button onclick="location.href='#HtmlAu'">
                <a class="nav" href="#HtmlAu">HTML automação</a>
            </button>
            <button onclick="location.href='#AuCypress'">
                <a class="nav" href="#AuCypress">Cypress</a>
            </button>
            <button onclick="location.href='#PostmanApi'">
                <a class="nav" href="#PostmanApi">Testes de API</a>
            </button>
            <button onclick="location.href='#database'">
                <a class="nav" href="#database">Banco de dados</a>
            </button>
            <button onclick="location.href='#MobileAu'">
                <a class="nav" href="#MobileAu">Automação Mobile</a>
            </button>
            <button onclick="location.href='#syllabus'">
                <a class="nav" href="#syllabus">ISQTB Syllabus</a>
            </button>
            <button onclick="location.href='#cabecalho'" id="topbutton">&uarr; Top</button>
        </aside>
    </div>
    <footer class="rodape">

    </footer>
</body>
</html>